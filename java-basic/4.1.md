# 4. 클래스와 객체

## 4.1 객체 지향과 자바

### 객체 지향 언어의 특성

* 캡슐화(Encapsulation)
  * 객체를 캡슐로 싸서 내부를 보호하고 볼 수 없게 하는 것
  * 객체의 가장 본질적인 특징
  * 객체는 캡슐화가 기본원칙이다.
    * 하지만 외부와의 접속을 위해 몇 부분만 공개 노출한다.
  * 자바의 객체: 클래스(class)의 구성요소
    * 필드(멤버 변수)
    * 메소드(멤버 함수)

* 상속(Inheritance)

  * 상속은 슈퍼 클래스의 필드와 메소드를 물려받아 코드를 재사용함으로써, 코드 작성에 드는 시간과 비용을 절약한다.

  * 자식 클래스가 부모 클래스의 속성을 물려받고 기능을 추가하는 개념: 확장

  * 슈퍼 클래스(super class): 부모 클래스

  * 서브 클래스(sub class): 자식 클래스

  * 예시

    * ```java
      // 슈퍼 클래스
      class Animal{
          String name;
          int age;
          void eat(){...}
          void sleep(){...}
          void laugh(){...}
      }
      // 서브 클래스
      class Human extends Animal{
          String hobby;
          String job;
          void work(){...}
          void cry(){...}
          void laugh(){...}
      }
      ```

    * 여기서 Animal의 객체는

      * String name;
      * int age;
      * void eat();
      * void sleep();
      * void love();

    * Human의 객체는 Animal을 extends 하여

      * String name;
      * int age;
      * void eat();
      * void sleep();
      * void love();

      에 추가로 선언한

      * String hobby;
            String job;
            void work(){...}
            void cry(){...}
            void laugh(){...}

      가 된다.

* 다형성(Polymorphism)
  * 다형성은 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것을 말함.
  * 메소드 오버라이딩(overriding)
    * 슈퍼 클래스에서 구현된 메소드를 서브 클래스에서 동일한 이름으로 자신의 특성에 맞게 다시 구현하는 것
  * 메소드 오버로딩(overloading)
    * 클래스 내에서 이름이 같지만 서로 다르게 동작하는 메소드를 여러 개 만드는 것
    * 매개변수의 개수 또는 타입이 다르다면, 같은 이름을 사용해서 메소드를 정의할 수 있다.

### 오버로딩 vs 오버라이딩

참고: https://hyoje420.tistory.com/14

* #### 오버로딩

  * 오버로딩의 조건

    * 메소드의 이름이 같아야한다.

    * 매개변수의 개수나 타입이 달라야 한다.

    * '리턴값만' 다른 것은 오버로딩을 할 수 없다.(리턴형이 달라도 되고 같아도 된다.)

  * 접근 제어자도 자유롭게 지정해줄 수 있다.

    * 각 메소드의 접근 제어자를 public, default, protected, private으로 다르게 지정해줘도 상관없다.
    * 하지만 접근 제어자만 다르다고 오버로딩이 가능한 것은 아니다.

  * 결국 오버로딩은 매개변수의 차이로만 구현할 수 있다.

  * 오버로딩을 사용하는 이유

    * 같은 기능을 하는 메소드를 하나의 이름으로 사용할 수 있다.
      * 예) println 메소드는 인자 값으로 int, double, boolean, String 등의 다양한 타입의 매개변수들을 집어넣어도 콘솔창에 잘 뜬다.
    * 메소드의 이름을 절약할 수 있다.
      * 예) println 메소드가 int, double, boolean, String 등을 한번에 처리하지 않는다면 printInt, printDouble..과 같이 메소드들의 이름을 정해줘야 할 것이다.

* #### 오버라이딩

  * 오버라이딩의 조건
    * 메소드의 이름이 같아야한다.
    * 매개변수의 개수나 타입이 같아야 한다.
    * 리턴 값이 같아야 한다.
    * 선언부는 부모의 것과 완벽히 동일해야한다.
  * @Override
    * 어노테이션(Annotation): 직역하자면 주석
    * 일반적인 주석과는 다르게, 검증하는 기능을 한다.
    * 여기서는 오버라이딩을 검증한다.
    * 코드상으로 검사시, 오버라이딩이 실제로 시행되지 않았다면 컴파일시 오류 출력.
  * 오버라이딩에서 접근 제어자를 설정하는 규칙
    * 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.
      * 예) 슈퍼 클래스의 접근 제어자가 default라면 서브 클래스들은 default보다 같거나 더 넓은 범위의 접근제어자만 설정할 수 있으므로 default, protected, public 이 세 개의 접근 제어자를 사용할 수 있다.
    * 예외(Exception)는 부모 클래스의 메소드보다 많이 선언할 수 없다.
      * 예) 슈퍼 클래스에서 어떤 예외를 throws 한다면, 서브에서는 그 예외보다 더 큰 범위의 예외를 throws 할 수 없다.
    * static 메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.
      * 붐모 클래스의 static 메소드를 자식에서 같은 이름으로 정의할 수 있지만 이것은 다시 정의하는 것이 아니라 같은 이름의 static 메소드를 새로 정의하는 것이다.

![image-20230329134924112](C:\Users\kimjihyo\AppData\Roaming\Typora\typora-user-images\image-20230329134924112.png)

### 객체 지향 언어의 목적

객체 지향 언어는 절차 지향 언어의 단점을 보완하고 다음의 목적을 달성하기 위해 만들어졌다.

* 소프트웨어의 생산성 향상
* 실세계에 대한 쉬운 모델링