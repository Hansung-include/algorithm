# [Silver V] 소수 - 2581 

[문제 링크](https://www.acmicpc.net/problem/2581) 

### 성능 요약

메모리: 1228 KB, 시간: 0 ms

### 분류

수학(math), 정수론(number_theory), 소수 판정(primality_test)

### 문제 설명

<p>자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.</p>

<p>예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.</p>

### 입력 

 <p>입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.</p>

<p>M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.</p>

### 출력 

 <p>M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다. </p>

<p>단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.</p>



### 소스 코드

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

class Prime {
    boolean[] sieve;
    int limit;

    Prime(int limit) {
        this.limit = limit;
        sieve = new boolean[limit + 1];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        if (limit >= 2) sieve[2] = true;
        for (int p = 3; p <= limit; p += 2)
            if (isPrime(p)) for (int i = p * 2; i <= limit; i += p)
                sieve[i] = false;
    }

    boolean isPrime(int n) {
        return (n % 2 != 0 || n <= 2) && sieve[n];
    }

    ArrayList<Integer> getPrimesInRange(int from, int to) {
        ArrayList<Integer> res = new ArrayList<>();
        if (from <= 2 && 2 <= to) res.add(2);
        for (int n = from + (from % 2 == 0 ? 1 : 0); n <= to; n += 2)
            if (isPrime(n)) res.add(n);
        return res;
    }
}

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        ArrayList<Integer> numbers = new ArrayList<>();
        while (sc.hasNext()) numbers.add(sc.nextInt());
        sc.close();

        int N = numbers.get(0), M = numbers.get(1);
        ArrayList<Integer> primes = new Prime(M).getPrimesInRange(N, M);

        if (primes.size() == 0) System.out.println(-1);
        else System.out.printf("%d %d\n",
                primes.stream().reduce(Integer::sum).get().intValue(),
                primes.stream().min(Integer::compareTo).get().intValue());
    }
}
```



### 레거시 코드

```c++
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <queue>

const int maxInput = 10000;

char* initArray(int size, int value) {
	char* isPrime = (char*)malloc(size + 1);
	if (isPrime != NULL) memset(isPrime, value, size + 1);
	return isPrime;
}

std::queue<int> getPrimesInRange(int from, int to)
{
	char* isPrime = initArray(to, -1);

	std::queue<int> primes;
	if (from <= 2 && 2 <= to) primes.push(2);
	for (int i = 3; i <= to; i += 2) {
		if (isPrime[i]) {
			if (from <= i) primes.push(i);
			for (int j = i * 2; j <= to; j += i) isPrime[j] = 0;
		}
	}
	return primes;
}

int main()
{
	int M, N; scanf(" %d %d", &M, &N);
	
	auto primes = getPrimesInRange(M, N);
	int minPrime = maxInput + 1, sumPrimes = 0;
	while (!primes.empty())
	{
		int nextPrime = primes.front();
		primes.pop();
		
		if (nextPrime < minPrime) minPrime = nextPrime;
		sumPrimes += nextPrime;
	}

	if (sumPrimes == 0) printf("-1");
	else printf("%d\n%d", sumPrimes, minPrime);
	return 0;
}
```
